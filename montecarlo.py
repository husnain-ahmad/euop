import numpy as np
import math


class EC_Payoff:

    def __init__(self, strike):
        self.strike = strike

    def get_payoff(self, stock_price):
        if stock_price > self.strike:
            return stock_price - self.strike
        else:
            return 0


class GeometricBrownianMotion:
    """
    A class to simulate Geometric Brownian Motion paths for an asset.
    https://github.com/RomanMichaelPaolucci
    """

    def simulate_paths(self):
        while self.T - self.dt > 0:
            dWt = np.random.normal(0, math.sqrt(self.dt))  # Brownian motion
            dYt = self.drift * self.dt + self.volatility * dWt  # Change in price
            self.current_price += dYt  # Add the change to the current price
            self.prices.append(self.current_price)  # Append new price to series
            self.T -= self.dt  # Account for the step in time

    def __init__(self, initial_price, drift, volatility, Te):
        self.current_price = initial_price
        self.initial_price = initial_price
        self.drift = drift
        self.volatility = volatility
        self.dt = Te / 365
        self.T = 1
        self.prices = []
        self.simulate_paths()


def pricing(asset_price, strike, volatility, time_to_expire):

    # Model Parameters
    initial_price = asset_price
    paths = int(strike)
    drift = 0.08
    volatility = volatility
    dt = time_to_expire / 365
    T = 1
    price_paths = []

    # Generate a set of sample paths
    for i in range(0, paths):
        price_paths.append(GeometricBrownianMotion(initial_price, drift, volatility, T).prices)

    call_payoffs = []
    ec = EC_Payoff(100)
    risk_free_rate = .01
    for price_path in price_paths:
        call_payoffs.append(ec.get_payoff(price_path[-1]) / (1 + risk_free_rate))
        # We get the last stock price in the series generated by GBM to determine the payoff and discount it
        # by one year

    return np.average(call_payoffs) * 100  # Options are in blocks of 100


# def geo_paths(S, T, r, q, sigma, steps, N):
# https://www.codearmo.com/blog/pricing-options-monte-carlo-simulation-python
#     """
#     Inputs
#     #S = Current stock Price
#     #K = Strike Price
#     #T = Time to maturity 1 year = 1, 1 months = 1/12
#     #r = risk free interest rate
#     #q = dividend yield
#     # sigma = volatility
#
#     Output
#     # [steps,N] Matrix of asset paths
#     """
#     dt = T / steps
#     # S_{T} = ln(S_{0})+\int_{0}^T(\mu-\frac{\sigma^2}{2})dt+\int_{0}^T \sigma dW(t)
#     ST = np.log(S) + np.cumsum(((r - q - sigma ** 2 / 2) * dt + sigma * np.sqrt(dt) *
#                                 np.random.normal(size=(steps, N))), axis=0)
#
#     return np.exp(ST)
#
# # print(bS.EuropeanCall(282, 277.84, 0.03180, 23, 0.01258).price)
#
# S = 244.45 # stock price S_{0}
# K = 285 # strike
# T = 6/365 # time to maturity
# r = 0.01258 # risk free risk in annual %
# q = 0.0 # annual dividend rate
# sigma = 0.03180 # annual volatility in %
# steps = 100 # time steps
# # N = 1000 # number of trials
#
# N = 100000
# paths = geo_paths(S, T, r, q, sigma, steps, N)
# payoffs = np.maximum(paths[-1]-K, 0)
# option_price = np.exp(-r*T)*np.mean(payoffs)
# #
# # bs_price = bS.(S,K,T,r,q,sigma)
#
# # print(f"Black Scholes Price is {bs_price}")
# print(f"Simulated price is {option_price}")